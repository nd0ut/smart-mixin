var expect = require('expect.js');
var sinon = require('sinon');
var mixins = require('..');

describe('mixin into objects', function(){
    describe('basic functionality', function(){
        var klass, klassFunctionCalled, bothValue;
        beforeEach(function(){
           // <generated by 6to5 on Mon Feb 2 2015 (UTC)>
               "use strict";

                var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

                var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

                var BaseKlass = (function () {
                  function BaseKlass() {}

                  _prototypeProperties(BaseKlass, null, {
                    add: {
                      value: function add(x, y) {
                        return x + y;
                      },
                      writable: true,
                      configurable: true
                    }
                 });

                  return BaseKlass;
                })();

                var Klass = (function (BaseKlass) {
                  function Klass() {
                    if (Object.getPrototypeOf(Klass) !== null) {
                      Object.getPrototypeOf(Klass).apply(this, arguments);
                    }
                  }

                  _inherits(Klass, BaseKlass);

                  _prototypeProperties(Klass, null, {
                    setsCalled: {
                      value: function setsCalled() {
                        klassFunctionCalled = true;
                      },
                      writable: true,
                      configurable: true
                    },
                    both: {
                      value: function both() {
                        bothValue++;
                      },
                      writable: true,
                      configurable: true
                    }

                  });

                  return Klass;
                })(BaseKlass);
            // </ generated by 6to5 on Mon Feb 2 2015 (UTC) >
            klass = Klass;
            klassFunctionCalled = false;
            bothValue = 0;
        });

        var mixin = mixins({
            both: mixins.MANY
        });

        it('is sane', function(){
            mixin(klass, {});
            expect(new klass().add(3, 4)).to.be(7);
        });

        it('handles MANY correctly', function(){
            new klass().both();
            expect(bothValue).to.be(1);
            mixin(klass.prototype, {
                both: function(){ bothValue += 10 }
            });
            new klass().both();
            expect(bothValue).to.be(1+1+10);
        });


        it('creates non-enumerable methods', function(){
            mixin(klass.prototype, {
                nonenumerable: function(){}
            });
            expect('nonenumerable' in klass.prototype).to.be.ok();
            expect(Object.keys(klass.prototype).indexOf('nonenumerable')).to.be(-1);
        });

        it('doesn\'t attempt to defineProperty on existing source properties', function(){
            Object.defineProperty(klass.prototype, 'noconfig', {writable: true});
            mixin(klass.prototype, {
                noconfig: function(){}
            });
            expect('noconfig' in klass.prototype).to.be.ok();
            expect(Object.getOwnPropertyDescriptor(klass.prototype, 'noconfig')).to.eql({
                writable: true,
                enumerable: false,
                configurable: false,
                value: klass.prototype.noconfig
            });
        });


        it('returns the mixer result', function(){
            mixins({
                add: function(left, right){
                    return function(){ return 'sentinel' }
                }
            })(klass.prototype, {add: function(){}});
            expect(new klass().add()).to.be('sentinel');
        });

        it('allows mixer to return arbitrary values', function(){
            mixins({
                add: function(left, right){
                    return left.length + ' sentinel'
                }
            })(klass.prototype, {add: function(){}});
            expect(new klass().add).to.be('2 sentinel');
        });

        it('defaults to ONCE', function(){
            expect(function(){
                mixin(klass.prototype, {add: function(){}});
            }).to.throwException();
        });

        it('accepts rules as string', function(){
            var obj = {foo: {a: 2}};
            mixins({foo: 'MANY_MERGED_LOOSE'})(obj, {foo: {b: 3}});
            expect(obj.foo).to.be.eql({a: 2, b: 3});
        });
    });

    describe('nonFunctionProperty', function(){
        it('throws if both are defined', function(){
            expect(function(){
                mixins({})({foo: 'foo'}, {foo: 'bar'});
            }).to.throwException(/Cannot mixin.*foo.*types are String and String/g);
        });

        it('doesn\'t care which side the key is on', function(){
            var m = mixins({});
            var first = {foo: 'bar'};
            m(first, {});
            expect(first.foo).to.be('bar');

            var second = {};
            m(second, {foo: 'baz'});
            expect(second.foo).to.be('baz');
        });

        it('handles null correctly', function(){
            var m = mixins({});
            var first = {foo: null};
            m(first, {});
            expect(first.foo).to.be(null);

            var second = {};
            m(second, {foo: null});
            expect(second.foo).to.be(null);

            var third = {foo: null};
            expect(function(){
                m(third, {foo: null});
            }).to.throwException(/Cannot mixin.*foo.*types are Null and Null/g);

        });
    });

    describe('opts', function(){
        var klass;
        beforeEach(function(){
            function Klass(){};
            Klass.prototype.foo = function(){ return 'foo'; };
            Klass.prototype.bar = 'string bar';
            klass = Klass;
        });

        it('allows overriding unknownFunction', function(){
            function add(x, y){ return function(){ return x() + y() } };
            mixins({}, {unknownFunction: add})(klass.prototype, {foo: function(){ return 'baz' }});
            expect(new klass().foo()).to.be('foobaz');
        });

        it('calls nonFunctionProperty', function(){
            mixins({}, {
                nonFunctionProperty: function(a, b, key){
                    expect(a).to.be('string bar');
                    expect(b).to.be('sentinel');
                    expect(key).to.be('bar');
                    return 7;
                }
            })(klass.prototype, {bar: 'sentinel'});
            expect(klass.prototype.bar).to.be(7);
        });

        it('calls nonFunctionProperty when one is a function', function(){
            var fn = function(){};
            mixins({}, {
                nonFunctionProperty: function(a, b, key){
                    expect(a).to.be('string bar');
                    expect(b).to.be(fn);
                    expect(key).to.be('bar');
                    return 7;
                }
            })(klass.prototype, {bar: fn});
            expect(klass.prototype.bar).to.be(7);
        });
    });
});
